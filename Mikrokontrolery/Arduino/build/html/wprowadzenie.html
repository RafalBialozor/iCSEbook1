

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Wprowadzenie do Arduino &mdash; Arduino 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/test.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Arduino 1.0.0 documentation" href="index.html" />
    <link rel="next" title="Obsługa wejść i wyjść – wejścia i wyjścia cyfrowe" href="1temat.html" />
    <link rel="prev" title="Dokumentacja dla platformy Arduino" href="Arduino.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="1temat.html" title="Obsługa wejść i wyjść – wejścia i wyjścia cyfrowe"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Arduino.html" title="Dokumentacja dla platformy Arduino"
             accesskey="P">previous</a> |</li>
        <li><a href="Arduino.html">Arduino 1.0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="wprowadzenie-do-arduino">
<h1>Wprowadzenie do Arduino<a class="headerlink" href="#wprowadzenie-do-arduino" title="Permalink to this headline">¶</a></h1>
<div class="section" id="informacje-wstepne">
<h2>Informacje wstępne<a class="headerlink" href="#informacje-wstepne" title="Permalink to this headline">¶</a></h2>
<div class="section" id="co-to-jest-arduino">
<h3>Co to jest Arduino?<a class="headerlink" href="#co-to-jest-arduino" title="Permalink to this headline">¶</a></h3>
<p>Arduino jest narzędziem do tworzenia systemów mikroprocesorowych w oparciu o mikrokontrolery AVR (<a class="reference external" href="http://en.wikipedia.org/wiki/Atmel_AVR">wiki</a>). Jest to open-source’owa platforma obliczeniowa oparta na prostej konstrukcji sprzętowej i zintegrowanym środowisku programistycznym (IDE - integrated development environment), przeznaczona dla artystów, projektantów, hobbystów i każdego zainteresowanego tworzeniem interaktywnych obiektów i środowisk. Celem projektu jest przygotowywanie narzędzi - ogólnodostępnych, nie wymagających dużych nakładów finansowych, elastycznych i łatwych w użyciu. Częściowo Arduino stanowi również alternatywę dla osób, które nie mają dostępu do bardziej zaawansowanych mikrokontrolerów, wymagających bardziej skomplikowanych narzędzi.</p>
<p>Arduino składa się:</p>
<ul class="simple">
<li>z mikrokontrolera na płytce z układami pomocniczymi, sensorów i aktuatorów</li>
<li>oraz zintegrowanego środowiska programistycznego (IDE - integrated development environment).</li>
</ul>
<p>Arduino może zostać wykorzystane do tworzenia modułowych urządzeń z różnymi układami peryferyjnymi, takimi jak przyciski, czujniki, wyświetlacze, interfejsy komunikacyjne przewodowe oraz bezprzewodowe, sterowniki silników itp.</p>
</div>
<div class="section" id="dlaczego-arduino">
<h3>Dlaczego Arduino?<a class="headerlink" href="#dlaczego-arduino" title="Permalink to this headline">¶</a></h3>
<p>System Arduino upraszcza proces przygotowywania oprogramowania dla mikrokontrolera. Ideą przyświecającą twórcom Arduino było maksymalne uproszczenie części sprzętowej systemu, umożliwiające jego rozbudowę za pomocą dodatkowych modułów, które mogą być zaprojektowane własnoręcznie lub przygotowane przez innych użytkowników tego systemu. Do programowania mikrokontrolerów nie są wymagane żadne dodatkowe programatory. Wystarczy podłączyć płytkę sprzętową do portu USB komputera i można już programować mikrokontroler własnym oprogramowaniem. Dodatkowe atuty Arduino:</p>
<ul class="simple">
<li>Jest niedrogi – podstawowa płytka startowa Arduino Uno jest w cenie poniżej 100 zł.</li>
<li>Bezpłatne oprogramowanie Arduino działa w systemach Windows, Macintosh OS X i Linux.</li>
<li>Środowisko programistyczne jest łatwe w obsłudze dla początkujących i na tyle elastyczne, by mogli z niego korzystać zaawansowani programiści. Przygotowanie programu jest proste i zajmuje bardzo mało czasu.</li>
<li>System Arduino jest systemem typu open-source, dlatego też może być zmodyfikowany do własnych potrzeb przez doświadczonych programistów,</li>
<li>Jest niezwykle prosty dzięki modułowej konstrukcji zestawu ewaluacyjnego (Arduino Uno). Przygotowywana jest również bogata liczba modułów rozszerzających dla zestawu Arduino Uno, nazwanych AVT-Duino, dzięki którym można zbudować bardzo wiele niebanalnych urządzeń.</li>
</ul>
</div>
<div class="section" id="otwarty-sprzet-i-otwarte-oprogramowanie">
<h3>Otwarty sprzęt i otwarte oprogramowanie<a class="headerlink" href="#otwarty-sprzet-i-otwarte-oprogramowanie" title="Permalink to this headline">¶</a></h3>
<p>Specyfikacja sprzętowa jest ogólnodostępna. Pliki CAD są udostępnione na licencji Creative Commons Attribution Share-Alike 2.5 i jest dostępny na stronie projektu <a class="reference external" href="http://arduino.cc/">Arduino</a>. Dostępne są również dokładne schematy budowy niektórych wersji układów Arduino. Układ można zbudować samodzielnie lub kupić (nie ma jednego oficjalnego producenta), każdy może produkować i sprzedawać zarówno układy zbudowane z oryginalnych planów, jak i własne modyfikacje. Kod źródłowy IDE Arduino i biblioteki sprzętowe dla Arduino są udostępniane i rozpowszechniane na licencji GPLv2.</p>
<div class="section" id="arduino-uno">
<h4>Arduino Uno<a class="headerlink" href="#arduino-uno" title="Permalink to this headline">¶</a></h4>
<p>Podstawowym zestawem dla Arduino jest zestaw Arduino Uno. Ma wyprowadzone wszystkie porty mikrokontrolera i interfejs USB, dzięki któremu można do mikrokontrolera przesyłać programy oraz przesyłać lub odczytywać dane przetworzone przez mikrokontroler. Aby uzyskać dodatkową funkcjonalność zestawu podstawowego, wystarczy włożyć do niego od góry dowolną płytkę rozszerzającą, zawierającą inne podzespoły (GPS, GSM, Ethernet, LCD itp.).</p>
<p>Mikrokontroler taktowany jest częstotliwością 16 MHz. W zestawie Uno można zastosować mikrokontrolery ATmega8 lub nowsze: Atmega168 i ATmega328. Komunikacja z komputerem odbywa się za pomocą wspomnianego interfejsu USB. Dzięki temu są dostępne sterowniki dla większości systemów operacyjnych.</p>
<div class="figure align-center">
<img alt="_images/ArduinoUno_R3_Front.jpg" src="_images/ArduinoUno_R3_Front.jpg" style="width: 500px;" />
<p class="caption">Płytka Arduino - widok z przodu</p>
</div>
<div class="figure align-center">
<img alt="_images/ArduinoUno_R3_Back.jpg" src="_images/ArduinoUno_R3_Back.jpg" style="width: 500px;" />
<p class="caption">Płytka Arduino - widok z tyłu</p>
</div>
</div>
</div>
</div>
<div class="section" id="arduino-ide">
<h2>Arduino IDE<a class="headerlink" href="#arduino-ide" title="Permalink to this headline">¶</a></h2>
<div class="section" id="oprogramowanie-arduino-ide">
<h3>Oprogramowanie Arduino IDE<a class="headerlink" href="#oprogramowanie-arduino-ide" title="Permalink to this headline">¶</a></h3>
<p>Projekty Arduino mogą pracować samodzielnie lub poprzez komunikację z oprogramowaniem zainstalowanym na komputerze (dostępnym na stronie <a class="reference external" href="http://arduino.cc/">http://arduino.cc/</a>), przy wykorzystaniu zintegrowanego środowiska programistycznego IDE (na przykład zbudowanego na <a class="reference external" href="http://www.processing.org/">Processing</a>, Flash, MaxMSP), które można dostosować do własnych potrzeb. Głównym założeniem twórców Processinng było stworzenie języka programowania na tyle prostego, aby był on przyjazny dla osób, nie posiadających doświadczenia związanego z programowaniem. Pierwotną grupą docelową byli artyści sztuk wizualnych, jednak z biegiem czasu okazało się, że język ten jest na tyle uniwersalny, że można go wykorzystywać do tworzenia innych aplikacji.</p>
<p>Oprogramowanie Arduino jest darmowe. Aplikacje pisane w Processing są multiplatformowe - mogą być uruchamiane na każdym systemie operacyjnym (Windows, OSX, Linux). IDE posiada edytor tekstu z takimi funkcjami jak podświetlanie składni czy automatyczne tworzenie wcięć w kodzie, oraz pozwala na kompilację i załadowanie programu do płyty Arduino. Zazwyczaj nie ma potrzeby dodatkowej edycji plików Makefile lub uruchamiania programów z listy poleceń.</p>
<p>Standardowo IDE Arduino zawiera bibliotekę C/C++ o nazwie <a class="reference external" href="http://wiring.org.co/">Wiring</a> z projektu o tej samej nazwie, dzięki czemu wykonywanie podstawowych operacji wejścia/wyjścia staje się znacznie łatwiejsze.</p>
<p>Przygotowany program należy poddać weryfikacji i kompilacji. Po wybraniu ikony <em>Verify/Compile</em> kompilator sprawdza składnię programu, a następnie poddaje ją kompilacji. Po jej prawidłowym zakończeniu program jest gotowy do wysłania do mikrokontrolera. W przypadku nieprawidłowości w kodzie, w dolnej części okienka systemu Arduino zostaną wyświetlone znalezione błędy. Przed wysłaniem programu do mikrokontrolera należy skonfigurować typ zestawu Arduino oraz numer portu w komputerze, do którego jest dołączony.</p>
<p>Ikona przycisku <em>Stop</em> zatrzymuje działanie Serial Monitor (monitor komunikacji szeregowej). Jest to pomocne, gdy przesyłane przez interfejs szeregowy RS232 informacje pojawiają się szybciej, niż można je zaobserwować.</p>
<p>Przycisk <em>Serial Monitor</em> uruchamia okno, w którym pojawiają się informacje wysyłane przez interfejs RS232 mikrokontrolera. Umożliwia ono także wysyłanie danych do mikrokontrolera. W oknie monitora dostępne są opcje automatycznego przewijania otrzymanych znaków, możliwość wyboru prędkości transmisji czy opcji związanych ze znakami końca linii. Monitor będzie pomocny podczas sprawdzania pracy programu i wyszukiwania w nim błędów.</p>
<div class="figure align-center">
<img alt="_images/Arduino_IDE.jpg" src="_images/Arduino_IDE.jpg" style="width: 500px;" />
<p class="caption">Arduino IDE</p>
</div>
</div>
<div class="section" id="uruchomienie-zestawu">
<h3>Uruchomienie zestawu<a class="headerlink" href="#uruchomienie-zestawu" title="Permalink to this headline">¶</a></h3>
<p>Zestaw może być zasilany z użyciem zewnętrznego zasilacza lub z interfejsu USB. Po połączeniu zestawu Arduino UNO z komputerem za pomocą przewodu USB należy w pierwszej kolejności zainstalować sterowniki USB wirtualnego portu COM. Sterowniki te znajdują się w pakiecie Arduino w katalogu Drivers. Należy jeszcze odpowiednio skonfigurować oprogramowanie Arduino IDE, korzystając z zakładki Tools z menu,a następnie ustawić numer portu, przez który będzie się odbywała komunikacja. Oprogramowanie Arduino IDE może się już komunikować z zestawem Arduino UNO. Prawidłowa komunikacja będzie sygnalizowana za pomocą diod TX oraz RX. Aby przesłać do zestawu przygotowany program, po jego weryfikacji i kompilacji wystarczy przycisnąć przycisk <em>Upload</em>. Problemy z komunikacją może powodować sprzęt lub nieprawidłowa konfiguracja portu komunikacyjnego. Zainstalowany numer portu powinien być zgodny z wybranym portem w oprogramowaniu Arduino IDE.</p>
</div>
</div>
<div class="section" id="jezyk-programowania">
<h2>Język programowania<a class="headerlink" href="#jezyk-programowania" title="Permalink to this headline">¶</a></h2>
<div class="section" id="program-glowny">
<h3>Program główny<a class="headerlink" href="#program-glowny" title="Permalink to this headline">¶</a></h3>
<p>Język Arduino IDE jest zbliżony do języka C. W języku Arduino, oprócz standardowych stałych, są dostępne stałe <tt class="docutils literal"><span class="pre">LOW</span></tt>, <tt class="docutils literal"><span class="pre">HIGH</span></tt>, <tt class="docutils literal"><span class="pre">INPUT</span></tt> oraz <tt class="docutils literal"><span class="pre">OUTPUT</span></tt>, związane z operacjami na liniach portów mikrokontrolera, natomiast typy zmiennych są identyczne jak dla języka C. Nowością w języku Arduino są funkcje związane z mikrokontrolerem.</p>
<p>Program główny systemu Arduino składa się z dwóch nieodzownych struktur: <tt class="docutils literal"><span class="pre">setup()</span></tt> oraz <tt class="docutils literal"><span class="pre">loop()</span></tt>. W pierwszej kolejności są inicjowane zmienne. Następnie w strukturze <tt class="docutils literal"><span class="pre">setup()</span></tt> inicjowane są tryby pracy lini mikrokontrolera, jego peryferia, linie portów mikrokontrolera oraz funkcje. Struktura ta jest wykonywana tylko raz, podczas włączania zasilania lub zerowania mikrokontrolera.</p>
<p>Po strukturze inicjującej wymagana jest struktura <tt class="docutils literal"><span class="pre">loop()</span></tt>, która tworzy niekończoną pętlę, w której wykonywany jest program sterujący pracą CPU. Działanie instrukcji w pętli będzie zależeć od użytkownika i napływających informacji z otoczenia mikrokontrolera. Oczywiście, jest możliwe wychodzenie z nieskończonej pętli do obsługiwanych funkcji z bibliotek lub własnych.</p>
</div>
<div class="section" id="biblioteki">
<h3>Biblioteki<a class="headerlink" href="#biblioteki" title="Permalink to this headline">¶</a></h3>
<p>Oprócz dostępnych instrukcji języka Arduino, dostępne są liczne biblioteki funkcji, umożliwiających obsługę różnych układów, dołączanych do mikrokontrolera. Są dostępne dwie grupy bibliotek:</p>
<ul>
<li><p class="first">Biblioteki dostępne z systemem Arduino, czyli biblioteki standardowe (biblioteki funkcji obsługi pamięci EEPROM, komunikacji z komputerem, obsługi wyświetlaczy LCD, transmisji sieciowej ETHERNET, obsługi kart pamięci SD, silników krokowych, programowej wersji interfejsu RS232 czy obsługi interfejsów SPI i I2C/TWI, w które został wyposażony w mikrokontroler). Do niektórych bibliotek standardowych wymagane będą elementy sprzętowe, jak choćby wyświetlacz LCD czy kontroler Ethernet.</p>
</li>
<li><p class="first">Niestandardowe biblioteki utworzone przez innych użytkowników systemu Arduino, które można ściągnąć z Internetu. Biblioteki niestandardowe można podzielić na kilka grup:</p>
<blockquote>
<div><ul class="simple">
<li>W grupie bibliotek komunikacyjnych można znaleźć biblioteki, umożliwiające obsługę wiadomości tekstowych, obsługi interfejsu 1-Wire, klawiatury z interfejsem PS2, obsługi telefonu komórkowego czy serwera www. Dostępne są również biblioteki, umożliwiające komunikacje zestawów Arduino ze sobą.</li>
<li>W grupie bibliotek obsługujących czujniki są dostępne biblioteki, obsługujące czujniki pojemnościowe oraz przyciski, w jakie jest wyposażona większość urządzeń.</li>
<li>Dostępna jest również grupa bibliotek obsługujących wyświetlacze graficzne oraz wyświetlacze wielosegmentowe LED.</li>
<li>Biblioteki w grupie generatory umożliwiają generowanie sygnału na dowolnym pinie mikrokontrolera lub z wykorzystaniem scalonych generatorów PWM.</li>
<li>Dostępna jest również grupa bibliotek dotyczących czasu. Można w niej znaleźć bibliotekę obsługującą zegar oraz kalendarz. Pozostałe biblioteki związane są z odmierzaniem czasu.</li>
<li>Ostatnia grupa dostępnych bibliotek dotyczy bibliotek do obsługi tekstów, przydatnych podczas wyświetlania tekstowych komunikatów na wyświetlaczu LCD lub wysyłanych do komputera.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="typy-pamieci">
<h3>Typy pamięci<a class="headerlink" href="#typy-pamieci" title="Permalink to this headline">¶</a></h3>
<p>W mikrokontrolerach programowanych przez Arduino istnieją trzy rodzaje pamięci:</p>
<ul class="simple">
<li>pamięć FLASH (przestrzeń programu). Przechowywany jest w niej program napisany w Arduino. Dane zapisane w tej pamięci nie są tracone po wyłączeniu zasilania.</li>
<li>pamięć SRAM (Static Random Access Memory) - pamięć na zmienne, czyli dane z obliczeń przeprowadzanych przez mikrokontroler. Dane w tej pamięci są tracone po wyłączeniu zasilania,</li>
<li>pamięć EEPROM - pamięć do stałego przechowywania danych. Zapisane dane nie są wymazywane po wyłączeniu zasilania. Można jej używać do długoterminowego przechowywania informacji.</li>
</ul>
</div>
</div>
<div class="section" id="przydatne-programy">
<h2>Przydatne programy<a class="headerlink" href="#przydatne-programy" title="Permalink to this headline">¶</a></h2>
<div class="section" id="eagle-pcb">
<h3>Eagle PCB<a class="headerlink" href="#eagle-pcb" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://cadsoft.de/">http://cadsoft.de/</a></p>
<p>Program typu CAD wspierający projektowanie schematów i płytek drukowanych. Jest komercyjny, ale z bezpłatną wersją do użytku domowego, posiadającą ograniczenia:</p>
<ul class="simple">
<li>Maksymalny rozmiar płytki 100 mm x 80 mm</li>
<li>Tylko dwie warstwy sygnałowe</li>
<li>Edytor schematów może tworzyć tylko jeden arkusz</li>
</ul>
<p>Pozwala otwierać, przeglądać i drukować projekty utworzone w pełnej wersji.</p>
</div>
<div class="section" id="fritzing">
<h3>Fritzing<a class="headerlink" href="#fritzing" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://fritzing.org">http://fritzing.org</a></p>
<p>Bardzo prosty w obsłudze program do tworzenia dokumentacji open-source, zaprojektowany do współpracy z Arduino. Nie wymaga od użytkownika znajomości zasad projektowania, bo cały proces opracowania schematu ideowego układu odbywa się poprzez kilka kliknięć myszką. Możliwe są trzy widoki układu:</p>
<ul class="simple">
<li>schemat,</li>
<li>płytka stykowa (breadboard),</li>
<li>płytka drukowana.</li>
</ul>
</div>
</div>
<div class="section" id="stale-i-funkcje-do-obslugi-mikrokontrolera">
<h2>Stałe i funkcje do obsługi mikrokontrolera<a class="headerlink" href="#stale-i-funkcje-do-obslugi-mikrokontrolera" title="Permalink to this headline">¶</a></h2>
<div class="section" id="constants">
<h3>Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h3>
<div class="section" id="high">
<h4>HIGH<a class="headerlink" href="#high" title="Permalink to this headline">¶</a></h4>
<p>Podczas odczytu lub zapisu pinu cyfrowego, możliwe jest przyjęcie przez niego tylko dwóch wartości: <tt class="docutils literal"><span class="pre">HIGH</span></tt> i <tt class="docutils literal"><span class="pre">LOW</span></tt>.</p>
<p>Znaczenie <tt class="docutils literal"><span class="pre">HIGH</span></tt> różni się nieco w zależności od tego, czy pin jest ustawiony na wejście czy na wyjście. Gdy pin jest skonfigurowany jako wejście z użyciem funkcji <tt class="docutils literal"><span class="pre">pinMode()</span></tt> i odczytywany poprzez <tt class="docutils literal"><span class="pre">digitalRead()</span></tt>, mikrokontroler będzie zwracać wartość <tt class="docutils literal"><span class="pre">HIGH</span></tt>, gdy na pinie obecne będzie napięcie <span class="math">\(3 V\)</span> lub więcej.</p>
<p>Pin może być również skonfigurowany jako wejście poprzez <tt class="docutils literal"><span class="pre">pinMode()</span></tt>, a następnie ustawiony na wartość <tt class="docutils literal"><span class="pre">HIGH</span></tt> poprzez <tt class="docutils literal"><span class="pre">digitalWrite()</span></tt>. To ustawi wewnętrzny <span class="math">\(20 kΩ\)</span> rezystor podwyższający i ustabilizuje wejście pinu na odczytywanie wartości <tt class="docutils literal"><span class="pre">HIGH</span></tt>, chyba że zewnętrzny obwód wymusi na nim przyjęcie wartości <tt class="docutils literal"><span class="pre">LOW</span></tt>. Ten sam efekt można szybciej uzyskać poprzez użycie argumentu <tt class="docutils literal"><span class="pre">INPUT_PULLUP</span></tt> (wejście podwyższające) w funkcji <tt class="docutils literal"><span class="pre">pinMode()</span></tt>.</p>
<p>Gdy pin jest skonfigurowany jako wyjście poprzez <tt class="docutils literal"><span class="pre">pinMode()</span></tt> i ustawiony na wartość <tt class="docutils literal"><span class="pre">HIGH</span></tt> z <tt class="docutils literal"><span class="pre">digitalWrite()</span></tt>, to ustala się na nim napięcie <span class="math">\(5 V\)</span>. W tym stanie może służyć jako źródło prądu i np. zasilać diodę LED podłączoną szeregowo poprzez rezystor do masy, lub do innego pinu skonfigurowanego jako wyjście i ustawionego na wartość <tt class="docutils literal"><span class="pre">LOW</span></tt>.</p>
</div>
<div class="section" id="low">
<h4>LOW<a class="headerlink" href="#low" title="Permalink to this headline">¶</a></h4>
<p>Podczas odczytu lub zapisu pinu cyfrowego, możliwe jest przyjęcie przez niego tylko dwóch wartości: <tt class="docutils literal"><span class="pre">HIGH</span></tt> i <tt class="docutils literal"><span class="pre">LOW</span></tt>.</p>
<p>Znaczenie <tt class="docutils literal"><span class="pre">LOW</span></tt> także różni się nieco w zależności od tego, czy pin jest ustawiony na wejście czy na wyjście. Gdy pin jest skonfigurowany jako wejście poprzez <tt class="docutils literal"><span class="pre">pinMode()</span></tt> i odczytywany poprzez <tt class="docutils literal"><span class="pre">digitalRead()</span></tt>, mikrokontroler zwracać będzie wartość <tt class="docutils literal"><span class="pre">LOW</span></tt>, jeśli na pinie obecne jest napięcie <span class="math">\(2 V\)</span> lub mniej.</p>
<p>Gdy pin jest skonfigurowany jako wyjście poprzez <tt class="docutils literal"><span class="pre">pinMode()</span></tt> i ustawiony na wartość <tt class="docutils literal"><span class="pre">LOW</span></tt> poprzez <tt class="docutils literal"><span class="pre">digitalWrite()</span></tt>, na pinie ustala się napięcie <span class="math">\(0 V\)</span>. W tym stanie może służyć jako masa i zamykać obwód np. diody LED połączonej szeregowo z poprzez rezystor do <span class="math">\(5 V\)</span>, albo innego pinu skonfigurowanego jako wyjście i ustawionego na watrtość <tt class="docutils literal"><span class="pre">HIGH</span></tt>.</p>
</div>
<div class="section" id="input">
<h4>INPUT<a class="headerlink" href="#input" title="Permalink to this headline">¶</a></h4>
<p><strong>Piny skonfigurowane jako wejście</strong></p>
<p>Cyfrowe piny mogą być używane jako wejścia, wejścia podwyższające i wyjścia. Zmiana przeznaczenia pinu poprzez funkcję <tt class="docutils literal"><span class="pre">pinMode()</span></tt> zmienia właściwości elektryczne pinu.</p>
<p>O pinach Arduino (Atmega) skonfigurowanych jako wejście poprzez <tt class="docutils literal"><span class="pre">pinMode()</span></tt> mówi się, że są w stanie wysokiej impedancji, ponieważ powodują one ekstremalnie mały spadek napięcia w obwodzie, który próbkują, porównywalny z <span class="math">\(100 MΩ\)</span> rezystorem połączonym szeregowo do pinu. To sprawia, że są one przydatne do odczytu czujnika, ale nie nadają się do zasilania diody LED.</p>
<p>Jeśli twój pin będzie skonfigurowany jako wejście, to będziesz chciał, by był on uziemiony. Jest to często realizowane poprzez rezystor obniżający.</p>
</div>
<div class="section" id="input-pullup">
<h4>INPUT_PULLUP<a class="headerlink" href="#input-pullup" title="Permalink to this headline">¶</a></h4>
<p><strong>Piny skonfigurowane jako wejścia podwyższające</strong></p>
<p>Cyfrowe piny mogą być używane jako wejścia, wejścia podwyższające i wyjścia. Zmiana przeznaczenia pinu poprzez funkcję <tt class="docutils literal"><span class="pre">pinMode()</span></tt>, zmienia właściwości elektryczne pinu.</p>
<p>Chip Atmega na Arduino posiada wewnętrzne rezystory podwyższające, które można wykorzystać. Jeśli wolisz je od zewnętrznych rezystorów obniżających, możesz użyć argumentu <tt class="docutils literal"><span class="pre">INPUT_PULLUP</span></tt> w <tt class="docutils literal"><span class="pre">pinMode()</span></tt>. To skutecznie odwraca zachowanie - <tt class="docutils literal"><span class="pre">HIGH</span></tt> oznacza wyłączony sensor, a <tt class="docutils literal"><span class="pre">LOW</span></tt> włączony.</p>
</div>
<div class="section" id="output">
<h4>OUTPUT<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h4>
<p><strong>Piny skonfigurowane jako wyjścia</strong></p>
<p>Cyfrowe piny mogą być używane jako wejścia, wejścia podwyższające i wyjścia. Zmiana przeznaczenia pinu poprzez funkcję <tt class="docutils literal"><span class="pre">pinMode()</span></tt>, zmienia właściwości elektryczne pinu.</p>
<p>O pinach Arduino skonfigurowanych jako wyjścia przy użyciu funkcji <tt class="docutils literal"><span class="pre">pinMode()</span></tt> mówi się, że są w stanie niskiej impedancji. Oznacza to, że mogą one zapewnić znaczną ilość prądu do innych układów. Piny Atmega mogą zasilać (prąd dodatni) lub uziemiać (prąd ujemy) aż do <span class="math">\(40 mA\)</span> do innych urządzeń / obwodów. To sprawia, że ​​są one przydatne do zasilania diod LED, ale bezużyteczne do odczytu sensorów.</p>
<p><strong>Uwaga:</strong></p>
<p>Piny skonfigurowane jako wyjscia mogą zostać uszkodzone lub zniszczone, jeśli zostaną zwarte. Ilość prądu dostarczana prze Atmega nie wystarcza także na zasilanie większości przekaźników i silników elektrycznych. Wymagany więc będzie jakiś układ sprzęgający.</p>
</div>
</div>
<div class="section" id="digital-i-o">
<h3>Digital I/O<a class="headerlink" href="#digital-i-o" title="Permalink to this headline">¶</a></h3>
<div class="section" id="pinmode">
<h4>pinMode()<a class="headerlink" href="#pinmode" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Konfiguruje określony pin jako wejście, wejście podwyższające lub wyjście.</p>
<p><strong>Uwaga:</strong></p>
<p>Piny analogowe mogą być używane jako piny cyfrowe, odnosząc się do nich jako A0, A1...</p>
<p><strong>Składnia:</strong></p>
<p>pinMode(&lt;pin&gt;, &lt;tryb&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;pin&gt;: numer pinu, którego tryb chcesz ustawić</p>
<p>&lt;tryb&gt;: <tt class="docutils literal"><span class="pre">INPUT</span></tt>, <tt class="docutils literal"><span class="pre">OUTPUT</span></tt> lub <tt class="docutils literal"><span class="pre">INPUT_PULLUP</span></tt></p>
</div>
<div class="section" id="digitalwrite">
<h4>digitalWrite()<a class="headerlink" href="#digitalwrite" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Przypisz wartość <tt class="docutils literal"><span class="pre">HIGH</span></tt> lub <tt class="docutils literal"><span class="pre">LOW</span></tt> do pinu cyfrowego.</p>
<p>Jeśli pin jest skonfigurowany jako wyjście poprzez <tt class="docutils literal"><span class="pre">pinMode()</span></tt>, jego napięcie będzie ustawione na odpowiednią wartość: <span class="math">\(5 V\)</span> lub <span class="math">\(3.3\)</span> V dla <tt class="docutils literal"><span class="pre">HIGH</span></tt> oraz <span class="math">\(0 V\)</span> (masa) dla <tt class="docutils literal"><span class="pre">LOW</span></tt>.</p>
<p>Jeśli pin jest skonfigurowany jako wejście, przypisanie wartości <tt class="docutils literal"><span class="pre">HIGH</span></tt> poprzez <tt class="docutils literal"><span class="pre">digitalWrite()</span></tt> włączy wewnętrzny <span class="math">\(20 kΩ\)</span> rezystor podwyższający. Przypisanie wartości <tt class="docutils literal"><span class="pre">LOW</span></tt> - wyłączy. Rezystor podwyższający wciąż zapewnia napięcie wystarczające, aby dioda LED lekko świeciła, więc jeśli diody wydają się działać, ale bardzo słabo, to jest to prawdopodobnie przyczyną ich zachowania. Rozwiązaniem jest ustawienie pinu na wyjście poprzez <tt class="docutils literal"><span class="pre">pinMode()</span></tt>.</p>
<p><strong>Ostrzeżenie:</strong></p>
<p>Pin <span class="math">\(13\)</span> jest trudniejszy w użyciu jako wejście cyfrowe od pozostałych pinów cyfrowych, ponieważ na większości płytek posiada on fabrycznie przymocowaną do niego diodę LED i rezystor. Jeśli włączysz swój wewnętrzny <span class="math">\(20 kΩ\)</span> rezystor podwyższający, to napięcie wyniesie około <span class="math">\(1.7 V\)</span> zamiast oczekiwanych <span class="math">\(5 V\)</span>, w związku ze spadkiem napięcia na diodzie LED i szeregowym rezystorze, co spowoduje, że pin <span class="math">\(13\)</span> zawsze zwróci wartość <tt class="docutils literal"><span class="pre">LOW</span></tt>. Jeśli musisz użyć pinu <span class="math">\(13\)</span> jako wejścia cyfrowego, użyj zewnętrznego rezystora obniżającego.</p>
<p><strong>Uwaga:</strong></p>
<p>Piny analogowe mogą być używane jako piny cyfrowe, odnosząc się do nich jako A0, A1...</p>
<p><strong>Składnia:</strong></p>
<p>digitalWrite(&lt;pin&gt;,&lt;wartość&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;pin&gt;: numer pinu, którego wartość chcesz ustawić</p>
<p>&lt;wartość&gt;: <tt class="docutils literal"><span class="pre">HIGH</span></tt> lub <tt class="docutils literal"><span class="pre">LOW</span></tt></p>
</div>
<div class="section" id="digitalread">
<h4>digitalRead()<a class="headerlink" href="#digitalread" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Odczytuje wartość z określonego pinu cyfrowego: <tt class="docutils literal"><span class="pre">LOW</span></tt> lub <tt class="docutils literal"><span class="pre">HIGH</span></tt>.</p>
<p><strong>Składnia:</strong></p>
<p>digitalRead (&lt;pin&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;pin&gt;: numer cyfrowego pinu, który chcesz odczytać (int)</p>
</div>
</div>
<div class="section" id="analog-i-o">
<h3>Analog I/O<a class="headerlink" href="#analog-i-o" title="Permalink to this headline">¶</a></h3>
<div class="section" id="analogreference">
<h4>analogReference()<a class="headerlink" href="#analogreference" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Konfiguruje napięcie odniesienia podawane na wejście analogowe (wartość maksymalną wejścia). Możliwe opcje:</p>
<ul class="simple">
<li>DEFAULT: domyślna, napięcie odniesienia dla przetwornika jest napięciem zasilającym mikrokontroler, czyli <span class="math">\(5 V\)</span> lub <span class="math">\(3.3 V\)</span>,</li>
<li>INTERNAL: wbudowane napięcie odniesienia równe <span class="math">\(1.1 V\)</span> dla ATmega168 (dla ATmega328 na Arduino Uno również),</li>
<li>EXTERNAL: zewnętrzne napięcie odniesienia dołączone do linii AREF, mieszczące się w przedziale od <span class="math">\(0 V\)</span> do <span class="math">\(5 V\)</span>.</li>
</ul>
<p><strong>Ostrzeżenie:</strong></p>
<p>Nie używaj napięcia niższego niż <span class="math">\(0 V\)</span> ani wyższego niż <span class="math">\(5 V\)</span> jako zewnętrznego napięcia odniesienia na pinie AREF. Jeśli używasz pinu AREF jako źródła zewnętrznego napięcia odniesienia, musisz ustawić typ EXTERNAL w funkcji <tt class="docutils literal"><span class="pre">analogReference()</span></tt>, zanim użyjesz funkcji <tt class="docutils literal"><span class="pre">analogRead()</span></tt>. W przeciwnym razie zewrzesz wewnętrznie generowane napięcie odniesienia pinu analogowego z pinem AREF, uszkadzając z dużym prawdopodobieństwem mikrokontroler na twojej płytce Arduino.</p>
<p><strong>Uwaga:</strong></p>
<p>Po zmianie analogowego napięcia odniesienia, kilka pierszych odczytów z <tt class="docutils literal"><span class="pre">analogRead()</span></tt> może nie być dokładne (stan nieustalony w obowodzie).</p>
<p><strong>Składnia:</strong></p>
<p>analogReference(&lt;typ&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;typ&gt;: umożliwia wybranie napięcia odniesienia spośród typów DEFAULT, INTERNAL lub EXTERNAL.</p>
</div>
<div class="section" id="analogread">
<h4>analogRead()<a class="headerlink" href="#analogread" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Odczytuje wartość z wybranego pinu analogowego. Płytka Arduino Uno posiada 6-cio kanałowy, 10-cio bitowy konwerter analogowo-cyfrowy (każdy bit może przyjąć wartość 0 lub 1, co daje nam <span class="math">\(2^{10} = 1024\)</span> możliwych stanów). To powoduje, że napięcia wyjścia zawierające się w przedziale od <span class="math">\(0 V\)</span> do <span class="math">\(5 V\)</span>, przekształcane będą odpowiednio na liczby z przedziału od 0 do 1023, dla napięcia <span class="math">\(0 V &lt; X &lt; 5 V\)</span>, uzyskując wartość <span class="math">\(\frac{X}{1023}\)</span> na wyjściu. Widzimy także, że rozdzielczość odczytu wyniesie około <span class="math">\(4.9 mV\)</span>. Wartość oraz rozdzielczość wejścia mogą być zmienione poprzez <tt class="docutils literal"><span class="pre">analogReference()</span></tt>.</p>
<p>Odczyt stanu analogowego wejścia zajmuje około <span class="math">\(0.1 ms\)</span>, więc maksymalne tempo odczytu wynosi około <span class="math">\(10^{3}\)</span> razy na sekundę.</p>
<p><strong>Uwaga:</strong></p>
<p>Jeśli wejście analogowego pinu nie jest do niczego podłączone, wartość zwrócona przez <tt class="docutils literal"><span class="pre">analogRead()</span></tt> będzie fluktuowała w zależności od szeregu czynników (np. wartości innych wejść analogowych, bliskości twojej ręki od płytki itd.).</p>
<p><strong>Składnia:</strong></p>
<p>analogRead(&lt;pin&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;pin&gt;: numer pinu analogowego (0, 1, ...), z którego odczytywana będzie wartość</p>
<p><strong>Zwraca:</strong></p>
<p>Liczbę całkowitą z zakresu od 0 do 1023</p>
</div>
<div class="section" id="analogwrite">
<h4>analogWrite()<a class="headerlink" href="#analogwrite" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Zapisuje wartość analogową (falę modulacji szerokości impulsów PWM, ang. pulse width modulation wave) do pinu. Może być używana do zapalania diody LED ze zmieniającą się jasnością, albo zasilania silnika elektrycznego z różnymi prędkościami. Po odwołaniu się do funkcji <tt class="docutils literal"><span class="pre">analogWrite()</span></tt>, pin będzie generował stabilny sygnał prostokątny o określonym cyklu pracy, aż do ponownego wywołania funkcji <tt class="docutils literal"><span class="pre">analogWrite()</span></tt> (lub <tt class="docutils literal"><span class="pre">digitalRead()</span></tt>, <tt class="docutils literal"><span class="pre">digitalWrite()</span></tt>) na tym samym pinie. Częstotliwość sygnału PWM wynosi około <span class="math">\(490 Hz\)</span>.</p>
<p>Na płytce Arduino Uno funkcja ta jest dostępna na pinch 3, 5, 6, 9, 10 lub 11, i oznaczona jako ~&lt;pin&gt;.</p>
<p>Nie musisz używać funkcji <tt class="docutils literal"><span class="pre">pinMode()</span></tt>, aby ustawić pin jako wyjście zanim odwołasz się do funkcji <tt class="docutils literal"><span class="pre">analogWrite()</span></tt>.</p>
<p>Funkcja <tt class="docutils literal"><span class="pre">analogWrite()</span></tt> nie ma nic wspólnego z pinami analogowymi oraz z funkcją <tt class="docutils literal"><span class="pre">analogRead()</span></tt>.</p>
<p><strong>Uwaga:</strong></p>
<p>Cykle pracy fal PWM na pinach 5 i 6 będą dłuższe niż ich oczekiwana wartość. Jest to spowodowane interakcją funkcii <tt class="docutils literal"><span class="pre">millis()</span></tt> oraz <tt class="docutils literal"><span class="pre">delay()</span></tt>, dzielących ten sam wewnętrzny licznik, który służy do generowania tych fal. Będzie to zwłaszcza widoczne przy niskich wartościach cyklów pracy (0 – 10), powodując, że ustalenie wartości 0 niekoniecznie spowoduje całkowite wyłączenie pinów 5 oraz 6.</p>
<p><strong>Składnia:</strong></p>
<p>analogWrite(&lt;pin&gt;, &lt;value&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;pin&gt;: numer pinu, na którym zapisywana będzie wartość: 3, 5, 6, 9, 10 lub 11.</p>
<p>&lt;value&gt;: cykl pracy (iloraz czasu włączenia pinu do jego wyłączenia) z zakresu od 0 do 255 (w związku z 8 bitowością pinu), odpowiadający odpowiednio stałemu wyłączeniu i stałemu włączeniu.</p>
</div>
</div>
<div class="section" id="advanced-i-o">
<h3>Advanced I/O<a class="headerlink" href="#advanced-i-o" title="Permalink to this headline">¶</a></h3>
<div class="section" id="tone">
<h4>tone()<a class="headerlink" href="#tone" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Generuje w pinie sygnał prostokątny o ustalonej częstotliwości (i 50% cyklu pracy). Czas trwania sygnału można podać jawnie, w przeciwnym razie sygnał będzie generowany do momentu wywołania funkcji <tt class="docutils literal"><span class="pre">noTone()</span></tt>. Do pinu może być podłączony głośniczek piezoelektryczny (buzzer), aby wydobywać dźwięki.</p>
<p>Tylko jeden dźwięk może być generowany w tym samym momencie. Jeśli dźwięk jest już grany na innym pinie, odwołanie się do funkcji <tt class="docutils literal"><span class="pre">tone()</span></tt> nie przyniesie żadnego efektu. Natomiast gdy wydobywa się z tego samego pinu, jej wywołanie ponownie ustawi jego częstotliwość.</p>
<p>Używanie funkcji <tt class="docutils literal"><span class="pre">tone()</span></tt> będzie interferować z wyjściem PWM na pinach 3 i 11.</p>
<p><strong>Uwaga:</strong></p>
<p>Jeśli chcesz grać różne wysokości tego samego dźwięku na wielu pinach, musisz wywołać funkcję <tt class="docutils literal"><span class="pre">noTone()</span></tt> na poprzednim pinie, zanim wywołasz funkcję <tt class="docutils literal"><span class="pre">Tone()</span></tt> na następnym.</p>
<p><strong>Składnia:</strong></p>
<p>tone(&lt;pin&gt;, &lt;częstotliwość&gt;)</p>
<p>tone(&lt;pin&gt;, &lt;częstotliwość&gt;, &lt;czas_trwania_sygnału&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;pin&gt;: pin na którym ma zostać wygenerowany sygnał prostokątny</p>
<p>&lt;częstotliwość&gt;: częstotliwość sygnału w Hz – typ: unsigned int</p>
<p>&lt;czas_trwania_sygnału): opcjonalny, czas trwania sygnału w ms – typ: unsigned long</p>
</div>
<div class="section" id="notone">
<h4>noTone()<a class="headerlink" href="#notone" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Zatrzymuje generowanie sygnału prostokątego zainicjowanego przez funkcję <tt class="docutils literal"><span class="pre">tone()</span></tt>. Nie daje żadnego efektu gdy sygnał nie jest generowany.</p>
<p><strong>Uwaga:</strong></p>
<p>Jeśli chcesz grać różne wysokości tego samego dźwięku na wielu pinach, musisz wywołać funkcję <tt class="docutils literal"><span class="pre">noTone()</span></tt> na poprzednim pinie, zanim wywołasz funkcję <tt class="docutils literal"><span class="pre">Tone()</span></tt> na następnym.</p>
<p><strong>Składnia:</strong></p>
<p>noTone(&lt;pin&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;pin&gt;: pin, na którym generowanie sygnału prostokątnego ma zostać zakończone.</p>
</div>
<div class="section" id="shiftln">
<h4>shiftln()<a class="headerlink" href="#shiftln" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Przesuwa bajt danych po jednym bicie. Zaczyna albo od najbardziej znaczącego bitu (pierwszy po lewej), albo od najmniej znaczącego (pierwszy po prawej). Dla każdego bitu, clock pin ustawia się na wartość <tt class="docutils literal"><span class="pre">HIGH</span></tt>, bit jest odczytywany ze strumienia danych, a potem clock pin wraca z powrotem do wartości <tt class="docutils literal"><span class="pre">LOW</span></tt>.</p>
<p><strong>Uwaga:</strong></p>
<p>To jest implementacja software&#8217;owa. Arduino dostarcza także bibliotekę SPI, która wykorzystuje implementację hardware&#8217;ową, która jest szybsza, ale działa tylko dla określonych pinów.</p>
<p><strong>Składnia:</strong></p>
<p>bite incoming = shiftIn(&lt;pin_danych&gt;, &lt;clock_pin&gt;, &lt;porządek_bitów&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;pin_danych&gt;: pin, na którym wchodzić będą kolejne bity – typ: int</p>
<p>&lt;clock_pin&gt;: przełączany pin sygnalizujący odczyt sygnału z pinu danych</p>
<p>&lt;porządek_bitów&gt;: kolejność w jakiej przesuwane mają być bity: MSBFIRST (ang. most significant bit first – najbardziej znaczący bit jako pierwszy) lub LSBFIRST ( ang. least significant bit first – najmniej znaczący bit jako pierwszy)</p>
<p><strong>Zwraca:</strong></p>
<p>Odczytana wartość – bajt.</p>
</div>
<div class="section" id="pulsein">
<h4>pulseIn()<a class="headerlink" href="#pulsein" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Zwraca długość impulsu (<tt class="docutils literal"><span class="pre">HIGH</span></tt> lub <tt class="docutils literal"><span class="pre">LOW</span></tt>) na pinie. Dla przykładu, jeśli wartość domyślna to <tt class="docutils literal"><span class="pre">HIGH</span></tt>, funkcja <tt class="docutils literal"><span class="pre">pulseIn()</span></tt> oczekuje, aż dany pin przejdzie w stan <tt class="docutils literal"><span class="pre">HIGH</span></tt> i zaczyna odliczać czas, a następnie czeka aż pin przejdzie w stan <tt class="docutils literal"><span class="pre">LOW</span></tt> i zatrzymuje odliczanie. Na koniec zwraca długość impulsu w ms. Jeśli imuls nie pojawi się w określonym w funkcji czasie, zwraca ona wartość 0.</p>
<p>Odczyt czasu tej funkcji został określony empirycznie i prawdopodobnie będzie obarczony błędami dla dłuższych impulsów. Poprawnie działa dla impulsów z przedziału od <span class="math">\(10 ms\)</span> do <span class="math">\(3 min\)</span>.</p>
<p><strong>Składnia:</strong></p>
<p>pulseIn(&lt;pin&gt;, &lt;wartość&gt;)</p>
<p>pulseIn(&lt;pin&gt;, &lt;wartość&gt;, &lt;czas_oczekiwania&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;pin&gt;: numer pinu, na którym chcesz odczytać długość impulsu</p>
<p>&lt;wartość&gt;: typ impulsu – <tt class="docutils literal"><span class="pre">HIGH</span></tt> lub <tt class="docutils literal"><span class="pre">LOW</span></tt></p>
<p>&lt;czas_oczekiwania&gt;: opcjonalny, liczba ms oczekiwania na rozpoczęcie impulsu, domyślnie <span class="math">\(1000 ms\)</span>.</p>
<p><strong>Zwraca:</strong></p>
<p>Długość impulsu w ms lub 0, jeśli impuls nie zaczął się w czasie mniejszym niż czas oczekiwania.</p>
</div>
</div>
<div class="section" id="time">
<h3>Time<a class="headerlink" href="#time" title="Permalink to this headline">¶</a></h3>
<div class="section" id="milis">
<h4>milis()<a class="headerlink" href="#milis" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Zwraca liczbę ms od kiedy płytka Arduino rozpoczęła działanie bierzącego programu. Po przekroczeniu około 50 dni od momentu włączenia i nieprzerwanego działania programu zakres liczby typu unsigned long wyczerpie się i program zacznie naliczać czas od nowa.</p>
<p><strong>Zwraca:</strong></p>
<p>liczbę ms od momentu rozpoczęcia programu – typ: unsigned long.</p>
</div>
<div class="section" id="micros">
<h4>micros()<a class="headerlink" href="#micros" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Zwraca liczbę μs od kiedy płytka Arduino rozpoczęła działanie bierzącego programu. Po przekroczeniu około <span class="math">\(70 min\)</span> od momentu włączenia i nieprzerwanego działania programu, zakres liczby typu unsigned long wyczerpie się i program zacznie naliczać czas od nowa.</p>
<p><strong>Zwraca:</strong></p>
<p>liczbę μs od momentu rozpoczęcia programu – typ: unsigned long.</p>
</div>
<div class="section" id="delay">
<h4>delay()<a class="headerlink" href="#delay" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Zatrzymuje działanie programu na określoną ilość czasu w ms.</p>
<p><strong>Uwaga:</strong></p>
<p>Mimo że łatwo jest wykorzystać funkcję <tt class="docutils literal"><span class="pre">delay()</span></tt> do uzyskania migającej diody LED, a wiele programów używa krótkich opóźnień np. do regulowania przełącznika, używanie funkcji <tt class="docutils literal"><span class="pre">delay()</span></tt> ma znaczącą wadę. Żaden inny odczyt z sensorów, operacja matematyczna lub operacja na pinie nie może zostać wykonana w trakcie działania funkcji <tt class="docutils literal"><span class="pre">delay()</span></tt>, więc w efekcie przeprowadza ona całą aktywność układu w stan wstrzymania.</p>
<p>Dla alternatywnych sposobów regulowania czasem wykonywania zobacz funkcję <tt class="docutils literal"><span class="pre">milis()</span></tt>. Bardziej doświadczeni programiści z reguły unikają używania funkcji <tt class="docutils literal"><span class="pre">delay()</span></tt> na czas dłuższy niż <span class="math">\(100 ms\)</span>, chyba że program jest bardzo prosty.</p>
<p>Niektóre procesy na chipie Arduino wykonują się normalnie podczas działania funkcji <tt class="docutils literal"><span class="pre">delay()</span></tt>. Komunikacja seryjna występująca na pinie RX jest zapisywana, a wartości PWM na pinach są zachowywane.</p>
<p><strong>Składnia:</strong></p>
<p>delay(&lt;czas_zatrzymania&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;czas_zatrzymania&gt;: czas zatrzymania programu w ms.</p>
</div>
<div class="section" id="delaymicroseconds">
<h4>delayMicroseconds()<a class="headerlink" href="#delaymicroseconds" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Zatrzymuje działanie programu na określoną ilość czasu w μs.</p>
<p>Obecnie największą wartością zwracającą dokładne opóźnienie jest 16383, może się zmienić dopiero w przyszłych wersjach Arduino, więc dla dłuższych przedziałów czasu zaleca się użwanie funkcji <tt class="docutils literal"><span class="pre">delay()</span></tt>.</p>
<p><strong>Uwaga:</strong></p>
<p>Funkcja <tt class="docutils literal"><span class="pre">delayMicroseconds()</span></tt> działa bardzo dokładnie dla przedziałów większych od <span class="math">\(3 μs\)</span>.</p>
<p><strong>Składnia:</strong></p>
<p>delayMircoseconds(&lt;czas_zatrzymania&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;czas_zatrzymania&gt;: czas zatrzymania programu w μs.</p>
</div>
</div>
<div class="section" id="math">
<h3>Math<a class="headerlink" href="#math" title="Permalink to this headline">¶</a></h3>
<div class="section" id="constrain">
<h4>constrain()<a class="headerlink" href="#constrain" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Ogranicza liczbę do przedziału domkniętego.</p>
<p><strong>Składnia:</strong></p>
<p>constrain(&lt;liczba&gt;, &lt;ograniczenie_dolne&gt;, &lt;ograniczenie_górne&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;liczba&gt;: liczba, którą chcemy ograniczyć</p>
<p>&lt;ograniczenie_dolne&gt;: liczba, bedąca ogr. dolnym przedziału</p>
<p>&lt;ograniczenie_górne&gt;: liczba, będąca ogr. górnym przedziału</p>
<p><strong>Zwraca:</strong></p>
<p>x – liczba, a – ogr. dolne, b – ogr. Górne</p>
<p>a: x &lt; a</p>
<p>x: a = &lt; x &amp; x &lt;= b</p>
<p>b: b &lt; x</p>
<p><strong>Przykład:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">sensorValue</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="n">sensorValue</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
<span class="c1">// ogranicza zakres wartości sensora do przedziału [10, 150]</span>
</pre></div>
</div>
</div>
<div class="section" id="map">
<h4>map()<a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Transformuje liczbę do innej skali liczbowej.</p>
<p>Nie ogranicza liczby do przedziału domkniętego, ponieważ wartości z poza zakresu są zamierzone i przydatne. Aby uzyskać efekt ograniczenie do przedziału domkniętego, należy przed lub po użyciu funkcji <tt class="docutils literal"><span class="pre">map()</span></tt> zastosować funkcję <tt class="docutils literal"><span class="pre">constrain()</span></tt>.</p>
<p>Warto zauważyć, że “ograniczenia dolne” któregokolwiek z zakresów, mogą być większe niż “ograniczenia górne”. W efekcie funkcja <tt class="docutils literal"><span class="pre">map()</span></tt> może być używana do odwracania zakresu liczb.</p>
<p>Funkcja <tt class="docutils literal"><span class="pre">map()</span></tt> używa liczb całkowitych do obliczeń i nie jest w stanie wygenerować ułamków. Wykonywane dzielenie będzie więc dzieleniem całkowitym.</p>
<p><strong>Składnia:</strong></p>
<p>map(&lt;liczba&gt;,&lt;ograniczenie_dolne_początkowe&gt;,&lt;ograniczenie_górne_początkowe&gt;,&lt;ograniczenie_dolne_końcowe&gt;,&lt;ograniczenie_górne_końcowe&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;liczba&gt;: liczba, którą chcemy przetransformować</p>
<p>&lt;ograniczenie_dolne_początkowe&gt;: początkowe ograniczenie dolne liczby</p>
<p>&lt;ograniczenie_górne_początkowe&gt;: początkowe ograniczenie górne liczby</p>
<p>&lt;ograniczenie_dolne_końcowe&gt;: końcowe ograniczenie dolne liczby</p>
<p>&lt;ograniczenie_górne_końcowe&gt;: końcowe ograniczenie górne liczby</p>
<p><strong>Zwraca:</strong></p>
<p>Przetransformowaną wartość.</p>
<p><strong>Przykład:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1023</span><span class="p">);</span>

<span class="c1">// x będzie równy 4x</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">255</span><span class="p">);</span>

<span class="c1">// x będzie równy -x</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bits-and-bytes">
<h3>Bits and Bytes<a class="headerlink" href="#bits-and-bytes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="lowbyte">
<h4>lowByte()<a class="headerlink" href="#lowbyte" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Zwraca najmniej znaczący bajt (leżący najbardziej po prawej) ze zmiennej (np. słowa).</p>
<p><strong>Składnia:</strong></p>
<p>lowByte(&lt;zmienna&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;zmienna&gt;: dowolna zmienna</p>
<p><strong>Zwraca:</strong></p>
<p>bajt</p>
</div>
<div class="section" id="highbyte">
<h4>highByte()<a class="headerlink" href="#highbyte" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Zwraca najbardziej znaczący bajt (leżący najbardziej po lewej) ze zmiennej (np. słowa), lub drugi najmniej znaczący bajt (drugi od prawej) większej zmiennej.</p>
<p><strong>Składnia:</strong></p>
<p>highByte(&lt;zmienna&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;zmienna&gt;: dowolna zmienna</p>
<p><strong>Zwraca:</strong></p>
<p>bajt</p>
</div>
<div class="section" id="bitread">
<h4>bitRead()<a class="headerlink" href="#bitread" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Odczytuje bit z liczby.</p>
<p><strong>Składnia:</strong></p>
<p>bitRead(&lt;liczba&gt;, &lt;numer_bitu&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;liczba&gt;: liczba, z której chcemy odczytać bit.</p>
<p>&lt;numer_bitu&gt;: numer bitu, który chcemy odczytać. Numeracja przebiega co 1, zaczynając od 0 dla najmniej znaczącego bitu (leżącego najbardziej po prawej).</p>
<p><strong>Zwraca:</strong></p>
<p>Wartość bitu: 1 lub 0.</p>
</div>
<div class="section" id="bitwrite">
<h4>bitWrite()<a class="headerlink" href="#bitwrite" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Nadpisuje bit odczytany z liczby.</p>
<p><strong>Składnia:</strong></p>
<p>bitWrite(&lt;liczba&gt;, &lt;numer_bitu&gt;, &lt;wartość_logiczna&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;liczba&gt;: liczba, którą bit chemy nadpisać.</p>
<p>&lt;numer_bitu&gt;: numer bitu, który chcemy nadpisać. Numeracja przebiega co 1, zaczynając od 0 dla najmniej znaczącego bitu (leżącego najbardziej po prawej).</p>
<p>&lt;wartość_logiczna&gt;: wartość logiczna, jaką chcemy nadpisać na wybranym bicie: 1 lub 0.</p>
</div>
<div class="section" id="bitset">
<h4>bitSet()<a class="headerlink" href="#bitset" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Nadpisuje bit odczytany z liczby wartością logiczną 1.</p>
<p><strong>Składnia:</strong></p>
<p>bitSet(&lt;liczba&gt;, &lt;numer_bitu&gt;)</p>
<p><strong>Paramtery:</strong></p>
<p>&lt;liczba&gt;: liczba, której bit chemy nadpisać wartością logiczną 1.</p>
<p>&lt;numer_bitu&gt;: numer bitu, który chcemy nadpisać. Numeracja przebiega co 1, zaczynając od 0 dla najmniej znaczącego bitu (leżącego najbardziej po prawej).</p>
</div>
<div class="section" id="bitclear">
<h4>bitClear()<a class="headerlink" href="#bitclear" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Nadpisuje bit odczytany z liczby wartością logiczną 0.</p>
<p><strong>Składnia:</strong></p>
<p>bitClear(&lt;liczba&gt;, &lt;numer_bitu&gt;)</p>
<p><strong>Paramtery:</strong></p>
<p>&lt;liczba&gt;: liczba, której bit chemy nadpisać wartością logiczną 0.</p>
<p>&lt;numer_bitu&gt;: numer bitu, który chcemy nadpisać. Numeracja przebiega co 1, zaczynając od 0 dla najmniej znaczącego bitu (leżącego najbardziej po prawej).</p>
</div>
<div class="section" id="bit">
<h4>bit()<a class="headerlink" href="#bit" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Oblicza wartość wybranego bitu; n-ty bit ma wartość 2n.</p>
<p><strong>Składnia:</strong></p>
<p>bit(&lt;numer_bitu&gt;)</p>
<p><strong>Parametry:</strong></p>
<p>&lt;numer_bitu&gt;: numer bitu, który chcemy nadpisać. Numeracja przebiega co 1, zaczynając od 0 dla najmniej znaczącego bitu (leżącego najbardziej po prawej).</p>
<p><strong>Zwraca:</strong></p>
<p>Wartość bitu.</p>
</div>
</div>
<div class="section" id="interrupts">
<h3>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>interrupts()<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Odblokowuje interrupts (po tym gdy zostały one zablokowane przy pomocy funkcji <tt class="docutils literal"><span class="pre">noInterrupts()</span></tt>). Interrupts umożliwiają funkcjonowanie w tle pewnych istotnych zadań i są domyślnie odblokowane. Pewne funkcje przestaną działać, w momencie gdy interrupts są zablokowane, a przychodząca z programu komunikacja może być ignorowana. Jednakże interrupts mogą nieznacznie zakłócić synchronizację kodu, co sprawia, że ich celowe zablokowanie w krytycznych punktach kodu może być pożądane.</p>
<p><strong>Składnia:</strong></p>
<p>interrupts()</p>
</div>
<div class="section" id="nointerrupts">
<h4>noInterrupts()<a class="headerlink" href="#nointerrupts" title="Permalink to this headline">¶</a></h4>
<p><strong>Opis:</strong></p>
<p>Zablokowuje interrupts (do ich ponownego odblokowania należy użyć funkcji <tt class="docutils literal"><span class="pre">interrupts()</span></tt>). Interrupts umożliwiają funkcjonowanie w tle pewnych istotnych zadań i są domyślnie odblokowane. Pewne funkcje przestaną działać, w momencie gdy interrupts są zablokowane, a przychodząca z programu komunikacja może być ignorowana. Jednakże interrupts mogą nieznacznie zakłócić synchronizację kodu, co sprawia, że ich celowe zablokowanie w krytycznych punktach kodu może być pożądane.</p>
<p><strong>Składnia:</strong></p>
<p>noInterrupts()</p>
</div>
</div>
<div class="section" id="communication">
<h3>Communication<a class="headerlink" href="#communication" title="Permalink to this headline">¶</a></h3>
<div class="section" id="serial">
<h4>Serial<a class="headerlink" href="#serial" title="Permalink to this headline">¶</a></h4>
<p><strong>Serial – komunikacja seryjna</strong></p>
<p>Używana do komunikacji seryjnej płytki Arduino z komputerem lub innym urzadzeniem. Wszystkie płytki Arduino posiadają przynajmniej jeden port komunikacji seryjnej. Do komunikacji wewnętrznej używa pinów 0 (RX) i 1 (TX), natomiast do komunikacji z komputerem – łącza USB. Dlatego podczas jej używania nie mamy możliwości wykorzystywania pinów 0 i 1.</p>
<p>Aby komunikować się z płytką Arduino, możemy używać wbudowanego w jego środowisko monitora seryjnego, którego ikonka widoczna jest w prawym rogu paska narzędzi. Musimy tylko ustalić przepustowość wyrażoną w bit/s.</p>
</div>
<div class="section" id="stream">
<h4>Stream<a class="headerlink" href="#stream" title="Permalink to this headline">¶</a></h4>
<p><strong>Stream class</strong></p>
<p><em>Stream</em> jest podstawową klasą dla strumieni znakowych i binarych. Nie jest wywoływany bezpośrednio, lecz wywoływany pośrednio przez funkcje, których działanie się na nim opiera.</p>
<p><em>Stream</em> definiuje funkcje odczytu na Arduino. Podczas używania funkcji, które w swojej nazwie zawierają człon &#8216;read&#8217;, lub podobny, możemy spokojnie założyć, że odwołuje się on do klasy <em>Stream</em>.</p>
<p>Dla funkcji takich jak <tt class="docutils literal"><span class="pre">print()</span></tt>, <em>Stream</em> dziedziczy z klasy <em>Print</em>.</p>
</div>
</div>
</div>
<div class="section" id="bibliografia">
<h2>Bibliografia<a class="headerlink" href="#bibliografia" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Banzi Massimo, “Getting started with Arduino&#8221;</li>
<li>Wiązania Marcin, “Elektronika praktyczna”</li>
<li><a class="reference external" href="http://arduino.cc/">http://arduino.cc/</a></li>
<li><a class="reference external" href="http://nettigo.pl/">http://nettigo.pl/</a></li>
<li><a class="reference external" href="http://startet-kit.nettigo.pl/">http://startet-kit.nettigo.pl/</a></li>
<li><a class="reference external" href="http://www.o.bzzz.net/">http://www.o.bzzz.net/</a></li>
<li><a class="reference external" href="http://pl.wikipedia.org/wiki/Arduino">http://pl.wikipedia.org/wiki/Arduino</a></li>
</ol>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="Arduino.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Wprowadzenie do Arduino</a><ul>
<li><a class="reference internal" href="#informacje-wstepne">Informacje wstępne</a><ul>
<li><a class="reference internal" href="#co-to-jest-arduino">Co to jest Arduino?</a></li>
<li><a class="reference internal" href="#dlaczego-arduino">Dlaczego Arduino?</a></li>
<li><a class="reference internal" href="#otwarty-sprzet-i-otwarte-oprogramowanie">Otwarty sprzęt i otwarte oprogramowanie</a><ul>
<li><a class="reference internal" href="#arduino-uno">Arduino Uno</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#arduino-ide">Arduino IDE</a><ul>
<li><a class="reference internal" href="#oprogramowanie-arduino-ide">Oprogramowanie Arduino IDE</a></li>
<li><a class="reference internal" href="#uruchomienie-zestawu">Uruchomienie zestawu</a></li>
</ul>
</li>
<li><a class="reference internal" href="#jezyk-programowania">Język programowania</a><ul>
<li><a class="reference internal" href="#program-glowny">Program główny</a></li>
<li><a class="reference internal" href="#biblioteki">Biblioteki</a></li>
<li><a class="reference internal" href="#typy-pamieci">Typy pamięci</a></li>
</ul>
</li>
<li><a class="reference internal" href="#przydatne-programy">Przydatne programy</a><ul>
<li><a class="reference internal" href="#eagle-pcb">Eagle PCB</a></li>
<li><a class="reference internal" href="#fritzing">Fritzing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stale-i-funkcje-do-obslugi-mikrokontrolera">Stałe i funkcje do obsługi mikrokontrolera</a><ul>
<li><a class="reference internal" href="#constants">Constants</a><ul>
<li><a class="reference internal" href="#high">HIGH</a></li>
<li><a class="reference internal" href="#low">LOW</a></li>
<li><a class="reference internal" href="#input">INPUT</a></li>
<li><a class="reference internal" href="#input-pullup">INPUT_PULLUP</a></li>
<li><a class="reference internal" href="#output">OUTPUT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#digital-i-o">Digital I/O</a><ul>
<li><a class="reference internal" href="#pinmode">pinMode()</a></li>
<li><a class="reference internal" href="#digitalwrite">digitalWrite()</a></li>
<li><a class="reference internal" href="#digitalread">digitalRead()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analog-i-o">Analog I/O</a><ul>
<li><a class="reference internal" href="#analogreference">analogReference()</a></li>
<li><a class="reference internal" href="#analogread">analogRead()</a></li>
<li><a class="reference internal" href="#analogwrite">analogWrite()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-i-o">Advanced I/O</a><ul>
<li><a class="reference internal" href="#tone">tone()</a></li>
<li><a class="reference internal" href="#notone">noTone()</a></li>
<li><a class="reference internal" href="#shiftln">shiftln()</a></li>
<li><a class="reference internal" href="#pulsein">pulseIn()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#time">Time</a><ul>
<li><a class="reference internal" href="#milis">milis()</a></li>
<li><a class="reference internal" href="#micros">micros()</a></li>
<li><a class="reference internal" href="#delay">delay()</a></li>
<li><a class="reference internal" href="#delaymicroseconds">delayMicroseconds()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#math">Math</a><ul>
<li><a class="reference internal" href="#constrain">constrain()</a></li>
<li><a class="reference internal" href="#map">map()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bits-and-bytes">Bits and Bytes</a><ul>
<li><a class="reference internal" href="#lowbyte">lowByte()</a></li>
<li><a class="reference internal" href="#highbyte">highByte()</a></li>
<li><a class="reference internal" href="#bitread">bitRead()</a></li>
<li><a class="reference internal" href="#bitwrite">bitWrite()</a></li>
<li><a class="reference internal" href="#bitset">bitSet()</a></li>
<li><a class="reference internal" href="#bitclear">bitClear()</a></li>
<li><a class="reference internal" href="#bit">bit()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interrupts">Interrupts</a><ul>
<li><a class="reference internal" href="#id1">interrupts()</a></li>
<li><a class="reference internal" href="#nointerrupts">noInterrupts()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#communication">Communication</a><ul>
<li><a class="reference internal" href="#serial">Serial</a></li>
<li><a class="reference internal" href="#stream">Stream</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#bibliografia">Bibliografia</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Arduino.html"
                        title="previous chapter">Dokumentacja dla platformy Arduino</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="1temat.html"
                        title="next chapter">Obsługa wejść i wyjść – wejścia i wyjścia cyfrowe</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/wprowadzenie.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="1temat.html" title="Obsługa wejść i wyjść – wejścia i wyjścia cyfrowe"
             >next</a> |</li>
        <li class="right" >
          <a href="Arduino.html" title="Dokumentacja dla platformy Arduino"
             >previous</a> |</li>
        <li><a href="Arduino.html">Arduino 1.0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Sara Mroz.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>